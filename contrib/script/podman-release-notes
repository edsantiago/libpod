#!/usr/bin/perl
#
# FIXME - script description here FIXME
#
# $Id: .perl-template,v 1.2 2020/03/03 20:08:31 esm Exp esm $
#
package FIXME::FIXME;

use v5.14;
use utf8;
use open qw( :encoding(UTF-8) :std );

use strict;
use warnings;

(our $ME = $0) =~ s|.*/||;
(our $VERSION = '$Revision: 1.2 $ ') =~ tr/[0-9].//cd;

# For debugging, show data structures using DumpTree($var)
#use Data::TreeDumper; $Data::TreeDumper::Displayaddress = 0;

use LWP::UserAgent;
use JSON::XS;

###############################################################################
# BEGIN user-customizable section

our $URL = 'https://api.github.com/graphql';

# WOOT! 2022-02-22 this gives us labels for a given PR
our $Query_Labels = '{
  repository(owner: "containers", name: "podman") {
    pullRequest(number: %d) {
      number
      title
      labels(first:30) {
        nodes {
          name
        }
      }
      closingIssuesReferences(first:30) {
        nodes {
          number
        }
      }
    }
  }
}';

our %By_Label;

# END   user-customizable section
###############################################################################

###############################################################################
# BEGIN boilerplate args checking, usage messages

sub usage {
    print  <<"END_USAGE";
Usage: $ME [OPTIONS] ARGS [...]

blah blah blah

OPTIONS:

  -v, --verbose  show verbose progress indicators
  -n, --dry-run  make no actual changes

  --help         display this message
  --version      display program name and version
END_USAGE

    exit;
}

# Command-line options.  Note that this operates directly on @ARGV !
our $debug   = 0;
our $force   = 0;
our $verbose = 0;
our $NOT     = '';              # print "blahing the blah$NOT\n" if $debug
sub handle_opts {
    use Getopt::Long;
    GetOptions(
        'debug!'     => \$debug,
        'dry-run|n!' => sub { $NOT = ' [NOT]' },
        'force'      => \$force,
        'verbose|v'  => \$verbose,

        help         => \&usage,
        version      => sub { print "$ME version $VERSION\n"; exit 0 },
    ) or die "Try `$ME --help' for help\n";
}

# END   boilerplate args checking, usage messages
###############################################################################

############################## CODE BEGINS HERE ###############################

# The term is "modulino".
__PACKAGE__->main()                                     unless caller();

# Main code.
sub main {
    # Note that we operate directly on @ARGV, not on function parameters.
    # This is deliberate: it's because Getopt::Long only operates on @ARGV
    # and there's no clean way to make it use @_.
    handle_opts();                      # will set package globals

    # Fetch command-line arguments.  Barf if too many.
    my $pr = shift(@ARGV)
        or die "$ME: missing PR argument; try $ME --help\n";
    die "$ME: Too many arguments; try $ME --help\n"                 if @ARGV;

    # FIXME: first do a git log, get PRs
    #   git log --merges --no-decorate c2f4747fe..HEAD
    my @prs = get_prs();

    # FIXME: get release-notes data from commit message? github description?
    # FIXME: show PR description / link, so Matt/reviewer can confirm?
    for my $pr (@prs) {
        doit($pr);
    }

    for my $k ("kind/bug", "breaking-change", "HTTP API") {
        print "\n", $k, "\n";
        for my $tuple (@{$By_Label{$k}}) {
            printf "  %6d %s\n", @$tuple;
        }
    }
}

sub get_prs {
    my @prs;

    my @cmd = qw(git log --merges --no-decorate f69fcb248..v4.0.0);
    open my $git_fh, '-|', @cmd
        or die "$ME: Cannot fork: $!\n";
    while (my $line = <$git_fh>) {
        push @prs, $1 if $line =~ /^\s*Merge pull request \#(\d+) from/;
    }
    close $git_fh
        or die "$ME: Error running @cmd: $!\n";

    return @prs;
}


sub doit {
    my $pr = shift;

    # FIXME: get PR state, confirm merged?
    # FIXME: find out if this PR closed an open issue? ("Linked issues")
    my $result = graphql_query(sprintf($Query_Labels, $pr));
    #    use Data::Dump; dd $result;
    my $info = $result->{data}{repository}{pullRequest};
    my @labels = map { $_->{name} } @{$info->{labels}{nodes}};
    my @closes = map { $_->{number} } @{$info->{closingIssuesReferences}{nodes}};

    #use Data::Dump; dd \@labels;
    printf "%5d %s\n", $pr, join(", ", @labels);
    for my $l (@labels) {
        push @{ $By_Label{$l} }, [ $pr, $info->{title} ];
    }
}


###################
#  graphql_query  #  Send a graphql query to host, return json response
###################
sub graphql_query {
    my $query = shift;

    my $ua = LWP::UserAgent->new;
    $ua->agent("$ME " . $ua->agent);              # Identify ourself

    my %headers = (
        'Authorization' => "bearer $ENV{GITHUB_TOKEN}",
        'Accept'        => "application/vnd.github.antiope-preview+json",
        'Content-Type'  => "application/json",
    );
    $ua->default_header($_ => $headers{$_}) for keys %headers;

    # Escape quotes
    $query =~ s/\"/\\"/g; $query =~ s/\n/ /g; $query =~ s/\s+/ /g;
    my $postquery = qq/{ "query": "$query" }/;
#    print $postquery; exit 0;

    my $res = $ua->post($URL, Content => $postquery);
    if ((my $code = $res->code) != 200) {
        use Term::ANSIColor qw(:constants);
        printf "%s%03d%s", ($code < 400 ? YELLOW : RED), $code, RESET;
        use Data::Dumper; print Dumper($res);
        exit 1;
    }

    return decode_json($res->content);
}
